"""
Test that sub-tasks are NOT generated by default for simple single-capability inputs.
"""
import asyncio
from app.agent.analyst import BusinessRequirementAnalyst


async def test_single_capability_no_subtasks():
    """
    Test that a simple single-capability input produces only one story ticket with no sub-tasks.
    
    Given: A simple single-capability input
    Expected: Only one story ticket (REQ-001) with no sub-tasks
    """
    analyst = BusinessRequirementAnalyst()
    
    # Simple single-capability input
    input_text = "Users can view their profile information."
    
    package = await analyst.analyze(
        input_text=input_text,
        source="test",
        context="subtask-test-001"
    )
    
    # Verify: Only parent requirements (stories) exist, no sub-tasks
    stories = [req for req in package.requirements if req.parent_id is None]
    subtasks = [req for req in package.requirements if req.parent_id is not None]
    
    print(f"\n=== Test Results ===")
    print(f"Total requirements: {len(package.requirements)}")
    print(f"Stories (parents): {len(stories)}")
    print(f"Sub-tasks (children): {len(subtasks)}")
    
    # Assertions
    assert len(stories) > 0, "At least one story should be created"
    assert len(subtasks) == 0, f"Expected 0 sub-tasks for simple input, but found {len(subtasks)}"
    
    # Verify story structure
    if stories:
        story = stories[0]
        print(f"\nStory ID: {story.id}")
        print(f"Story Summary: {story.summary}")
        print(f"Business Requirements: {len(story.business_requirements)}")
        print(f"Ticket Type: {story.ticket_type.value}")
        
        assert story.ticket_type.value == "story", f"Expected ticket_type='story', got '{story.ticket_type.value}'"
        assert story.parent_id is None, "Story should have no parent_id"
        assert len(story.business_requirements) >= 1, "Story should have at least one business requirement"
    
    print("\n✅ Test PASSED: No sub-tasks generated for simple single-capability input")
    return package


async def test_br_atomicity_multiple_obligations():
    """
    Test that when in_scope contains multiple distinct obligations, separate BRs are created.
    
    Given: "publish test plans to Jira for visibility"
    Expected: 
    - in_scope should contain items like "Publishing test plans" and "Associating with Jira tickets"
    - At least BR-001 (publish) and BR-002 (associate/link) should exist
    - Each BR should be atomic (one obligation per BR)
    """
    analyst = BusinessRequirementAnalyst()
    
    # Input that implies multiple obligations
    input_text = "The system must publish test plans to Jira for visibility and associate them with existing tickets."
    
    package = await analyst.analyze(
        input_text=input_text,
        source="test",
        context="atomicity-test-001"
    )
    
    stories = [req for req in package.requirements if req.parent_id is None]
    
    print(f"\n=== BR Atomicity Test Results ===")
    print(f"Total requirements: {len(package.requirements)}")
    print(f"Stories (parents): {len(stories)}")
    
    assert len(stories) > 0, "At least one story should be created"
    
    # Check the first story for atomicity
    story = stories[0]
    print(f"\nStory ID: {story.id}")
    print(f"Story Summary: {story.summary}")
    print(f"In-Scope Items: {story.scope_boundaries.in_scope}")
    print(f"Business Requirements Count: {len(story.business_requirements)}")
    
    # Verify we have business requirements
    assert len(story.business_requirements) >= 1, "Story should have at least one business requirement"
    
    # Check if in_scope has multiple items
    if len(story.scope_boundaries.in_scope) > 1:
        in_scope_count = len(story.scope_boundaries.in_scope)
        br_count = len(story.business_requirements)
        
        print(f"\nIn-Scope Items: {in_scope_count}")
        print(f"BR Count: {br_count}")
        
        # If in_scope has multiple distinct items, we should have multiple BRs
        # (or at least an open question if mismatch)
        if in_scope_count > br_count:
            # Check if there's an open question about atomicity
            has_atomicity_question = any(
                "obligation" in q.lower() or "atomic" in q.lower() or "business requirement" in q.lower()
                for q in story.open_questions if q != "N/A"
            )
            print(f"Open Questions: {story.open_questions}")
            if not has_atomicity_question:
                print("⚠️  WARNING: Multiple in_scope items but no atomicity question found")
    
    # Verify each BR is atomic (no compound behaviors)
    for idx, br in enumerate(story.business_requirements, 1):
        print(f"\nBR-{idx}: {br.statement}")
        
        # Check for compound patterns
        statement_lower = br.statement.lower()
        compound_indicators = [
            ' and the system shall',
            ', and the system shall',
            ' or the system shall',
        ]
        
        has_compound = any(indicator in statement_lower for indicator in compound_indicators)
        if has_compound:
            print(f"⚠️  WARNING: BR-{idx} appears to contain compound behaviors")
    
    print("\n✅ Test PASSED: BR atomicity checked")
    return package


async def test_input_based_atomicity_multiple_obligations():
    """
    Test that input text with explicit multiple obligations produces separate BRs.
    
    This tests the HARD REQUIREMENT: If input text explicitly references multiple
    system obligations, they MUST be represented as separate BRs, regardless of enhancement_mode.
    
    Given: "publish test plans to Jira and associate them with the originating issue"
    Expected: 
    - Two separate BRs: one for "publish" and one for "associate"
    - BR count >= 2
    - Each BR is atomic (one obligation per BR)
    """
    analyst = BusinessRequirementAnalyst()
    
    # Input that explicitly references multiple obligations
    input_text = "publish test plans to Jira and associate them with the originating issue"
    
    package = await analyst.analyze(
        input_text=input_text,
        source="test",
        context="input-atomicity-test-001"
    )
    
    stories = [req for req in package.requirements if req.parent_id is None]
    
    print(f"\n=== Input-Based Atomicity Test Results ===")
    print(f"Input: {input_text}")
    print(f"Total requirements: {len(package.requirements)}")
    print(f"Stories (parents): {len(stories)}")
    
    assert len(stories) > 0, "At least one story should be created"
    
    # Check the first story
    story = stories[0]
    print(f"\nStory ID: {story.id}")
    print(f"Story Summary: {story.summary}")
    print(f"Business Requirements Count: {len(story.business_requirements)}")
    
    # Verify we have at least 2 BRs (publish and associate)
    br_count = len(story.business_requirements)
    assert br_count >= 2, (
        f"Expected at least 2 BRs for input with explicit multiple obligations "
        f"('publish' and 'associate'), but found {br_count} BR(s)"
    )
    
    # Print all BRs
    print("\nBusiness Requirements:")
    for idx, br in enumerate(story.business_requirements, 1):
        print(f"  {br.id}: {br.statement}")
    
    # Verify each BR is atomic (no compound behaviors)
    for idx, br in enumerate(story.business_requirements, 1):
        statement_lower = br.statement.lower()
        compound_indicators = [
            ' and the system shall',
            ', and the system shall',
            ' or the system shall',
        ]
        
        has_compound = any(indicator in statement_lower for indicator in compound_indicators)
        assert not has_compound, (
            f"BR {br.id} contains compound behaviors and should be split: '{br.statement}'"
        )
    
    # Check for publish and associate keywords in BRs
    br_statements = [br.statement.lower() for br in story.business_requirements]
    has_publish = any('publish' in stmt for stmt in br_statements)
    has_associate = any('associate' in stmt or 'link' in stmt for stmt in br_statements)
    
    print(f"\nPublish found in BRs: {has_publish}")
    print(f"Associate/Link found in BRs: {has_associate}")
    
    # If we don't have both, check for open questions about atomicity
    if not (has_publish and has_associate):
        print(f"\nOpen Questions: {story.open_questions}")
        has_atomicity_question = any(
            "obligation" in q.lower() or "atomic" in q.lower() or "input" in q.lower()
            for q in story.open_questions if q != "N/A"
        )
        if has_atomicity_question:
            print("⚠️  Note: Open question found about atomicity - this is acceptable")
        else:
            print("⚠️  WARNING: Expected both 'publish' and 'associate' in BRs, but not found")
    
    print("\n✅ Test PASSED: Input-based atomicity verified")
    return package


async def test_multiple_brs_with_subtasks():
    """
    Test that when multiple distinct Business Requirements exist, sub-tasks may be created.
    """
    analyst = BusinessRequirementAnalyst()
    
    # Input with multiple distinct capabilities
    input_text = """
    The system must support user registration and user login.
    User registration allows new users to create accounts.
    User login allows existing users to authenticate.
    """
    
    package = await analyst.analyze(
        input_text=input_text,
        source="test",
        context="subtask-test-002"
    )
    
    stories = [req for req in package.requirements if req.parent_id is None]
    subtasks = [req for req in package.requirements if req.parent_id is not None]
    
    print(f"\n=== Test Results (Multiple Capabilities) ===")
    print(f"Total requirements: {len(package.requirements)}")
    print(f"Stories (parents): {len(stories)}")
    print(f"Sub-tasks (children): {len(subtasks)}")
    
    # For multiple capabilities, we expect multiple stories (one per capability)
    # Sub-tasks may or may not be created depending on decomposition criteria
    assert len(stories) >= 1, "At least one story should be created"
    
    print("\n✅ Test PASSED: Multiple capabilities handled")
    return package


async def main():
    """Run all tests."""
    print("Running sub-task generation tests...\n")
    
    try:
        # Test 1: Simple input should produce no sub-tasks
        await test_single_capability_no_subtasks()
        
        # Test 2: BR atomicity with multiple obligations
        await test_br_atomicity_multiple_obligations()
        
        # Test 3: Input-based atomicity (HARD REQUIREMENT)
        await test_input_based_atomicity_multiple_obligations()
        
        # Test 4: Multiple capabilities
        await test_multiple_brs_with_subtasks()
        
        print("\n" + "="*50)
        print("All tests completed successfully!")
        
    except AssertionError as e:
        print(f"\n❌ Test FAILED: {e}")
        raise
    except Exception as e:
        print(f"\n❌ Unexpected error: {e}")
        raise


if __name__ == "__main__":
    asyncio.run(main())

